use log::{info, debug, error};
use std::collections::{HashMap, HashSet};
use std::error::Error;
use std::sync::Arc;
use std::thread::sleep;

use crossbeam::atomic::AtomicCell;
use ctrlc;
use midir::{MidiOutput, MidiOutputConnection};
use crate::{Meter, Midi, Midibox, NOTE_OFF_MSG, NOTE_ON_MSG};
use crate::router::{Router, StaticRouter};

#[derive(Debug, Clone, Copy)]
pub struct PlayingNote {
    pub channel_id: usize,
    pub start_tick_id: u64,
    pub note: Midi,
}

pub struct Player {
    /// Describes the tempo that the player should use during playback.
    meter: Box<dyn Meter>,
    /// Describes the time spent playing in ticks.
    tick_id: u64,
    /// A unique identifier for notes generated by the player.
    note_id: u64,
    /// A description of the notes the player should play.
    ///
    /// The outer-most `Vec` contains the channels the `Player` is currently playing.
    ///
    /// Channels are played concurrently -- the player will cycle through each channel in lockstep,
    /// and emit all notes at the position corresponding to the current play time. There is no limit
    /// on the number of channels that can be played concurrently (subject to tempo and hardware
    /// limitations). Channels may have different lengths.
    ///
    /// Concretely, a channel is `Vec<Vec<Midi>>` where each position in the outermost vec
    /// represents notes to be played instantaneously in a single tick. When each position of the
    /// channel has been played, the play head will loop back to the beginning.
    ///
    /// TODO: Testing for multiple notes of different durations.
    /// TODO: Sparse channel representations since snapshots of Player should be immutable.

    channels: Vec<Vec<Vec<Midi>>>,
    /// A map from channel at index `key` into `usize` to `value`, the current play position (i.e.,
    /// the index into the `Vec<Vec<Midi>>` representing the channel.
    ///
    /// The sizes of `channels` and `positions` must be equal.
    positions: HashMap<usize, usize>,
    /// A map from a sounding note's ID to the note, decorated with metadata about how the note was
    /// generated.
    playing_notes: HashMap<u64, PlayingNote>,
}

impl Player {
    pub fn new(
        meter: Box<dyn Meter>,
        channels: Vec<Arc<dyn Midibox>>,
    ) -> Self {
        // initialize play positions for all channels to start (i.e., 0)
        let mut pos : HashMap<usize, usize> = HashMap::new();
        for i in 0..channels.len() {
            pos.insert(i, 0);
        }

        Player {
            meter,
            tick_id: 0,
            note_id: 0,
            channels: channels.into_iter()
                .map(|m| m.render())
                .collect(),
            positions: pos,
            playing_notes: HashMap::new(),
        }
    }

    /// Increment and return the note_id
    fn incr_note_id(&mut self) -> u64 {
        self.note_id += 1;
        return self.note_id;
    }

    /// Increment and return the tick_id
    pub fn do_tick(&mut self) -> u64 {
        self.tick_id += 1;
        sleep(self.meter.tick_duration());
        return self.tick_id;
    }

    /// Gets the current time in ticks since start
    pub fn time(&self) -> u64 {
        self.tick_id
    }

    /// Determines whether we need to poll the channel for new notes in the sequence
    /// Each channel may send a set of notes to the player -- but cannot send any more notes until
    /// those are done playing. So check that there are no active notes for the channel.
    fn should_poll_channel(&self, channel_id: usize) -> bool {
        self.playing_notes.values()
            .filter(|v| v.channel_id == channel_id)
            .count() == 0
    }

    /// Perform a non-blocking poll of all channels the player is connected to. Each channel may
    /// return a vectors of notes to play simultaneously.
    pub fn poll_channels(&mut self) -> Vec<PlayingNote> {
        for (channel_id, note_channel) in self.channels.clone().into_iter().enumerate() {
            if !self.should_poll_channel(channel_id) {
                continue;
            }

            let note_index = *(
                self.positions.get(&channel_id)
                .expect("missing play position for channel")
            );

            match note_channel.get(note_index) {
                Some(notes) => {
                    debug!("Channel {} sent notes {:?}", channel_id, notes);
                    for note in notes {
                        let note_id = self.incr_note_id();
                        if note.duration == 0 {
                            continue; // ignore zero-duration notes
                        }
                        // track the note we're about to play so that we can stop it after the
                        // number of ticks equaling the note's duration have elapsed.
                        self.playing_notes.insert(note_id, PlayingNote {
                            channel_id,
                            start_tick_id: self.tick_id,
                            note: *note,
                        });
                    }
                    self.positions.insert(channel_id, (note_index + 1) % note_channel.len());
                }
                None => {
                    error!("No input from channel {}", channel_id);
                }
            }
        }

        let mut notes: Vec<PlayingNote> = Vec::new();
        notes.extend(
            self.playing_notes
                .values()
                .filter(|note| note.start_tick_id == self.tick_id)
                .map(|note| note)
        );
        notes
    }

    pub fn clear_elapsed_notes(&mut self) -> Vec<PlayingNote> {
        let current_tick = self.tick_id;
        return self.clear_notes(|note| {
            return note.start_tick_id + (note.note.duration as u64) == current_tick;
        });
    }

    pub fn clear_all_notes(&mut self) -> Vec<PlayingNote> {
        return self.clear_notes(|_| true);
    }

    fn clear_notes<F>(&mut self, should_clear: F) -> Vec<PlayingNote> where
        F: Fn(&PlayingNote) -> bool
    {
        let mut notes: Vec<PlayingNote> = Vec::new();
        for (note_id, playing) in self.playing_notes.clone() {
            if should_clear(&playing) {
                self.playing_notes.remove(&note_id);
                notes.push(playing);
            }
        }

        notes
    }
}



pub struct PlayerConfig {
    pub router: Box<dyn Router>
}

impl PlayerConfig {
    pub fn empty() -> Self {
        PlayerConfig {
            router: Box::new(StaticRouter::new(0))
        }
    }

    pub fn for_port(port_id: usize) -> Self {
        PlayerConfig {
            router: Box::new(StaticRouter::new(port_id))
        }
    }
}

impl Router for PlayerConfig {
    fn route(&self, channel_id: usize) -> Option<&usize> {
        return self.router.route(channel_id);
    }

    fn required_ports(&self) -> HashSet<usize> {
        return self.router.required_ports();
    }
}

pub fn run(bpm: Box<dyn Meter>, sequences: Vec<Arc<dyn Midibox>>) {
    match try_run(PlayerConfig::empty(), bpm, sequences) {
        Ok(_) => (),
        Err(err) => println!("Error: {}", err)
    }
}

pub fn try_run(
    player_config: PlayerConfig,
    bpm: Box<dyn Meter>,
    sequences: Vec<Arc<dyn Midibox>>
) -> Result<(), Box<dyn Error>> {
    env_logger::init();

    // TODO: factor out MIDI connection logic into separate module with YAML config
    let midi_out = MidiOutput::new("Midi Outputs")?;
    let out_ports = midi_out.ports();

    let required_ports = player_config.required_ports();
    let mut port_id_to_conn: HashMap<usize, MidiOutputConnection> =
        HashMap::with_capacity(required_ports.len());

    for i in 0..out_ports.len() {
        let port = out_ports.get(i).expect("Missing midi port");
        let port_name = format!("midibox {}", i);
        let output = MidiOutput::new(&port_name)?;

        if required_ports.contains(&i) {
            let conn = output.connect(port, &port_name)?;
            port_id_to_conn.insert(i, conn);
        }
    }

    // flag to determine whether to keep running (e.g., while looping in sequence / player threads)
    let running = Arc::new(AtomicCell::new(true));
    let clean_up_finished = Arc::new(AtomicCell::new(false));

    let ctrlc_running = Arc::clone(&running);
    ctrlc::set_handler(move || ctrlc_running.store(false))?;

    let player_running = Arc::clone(&running);
    let player_cleanup_finished = Arc::clone(&clean_up_finished);

    let mut player = Player::new(
        bpm,
        sequences.clone()
    );

    info!("Player Starting.");
    while player_running.load() {
        debug!("Time: {}", player.time());
        for note in player.poll_channels() {
            route_note(&player_config, &mut port_id_to_conn, note, NOTE_ON_MSG)
        }
        player.do_tick();
        for note in player.clear_elapsed_notes() {
            route_note(&player_config, &mut port_id_to_conn, note, NOTE_OFF_MSG)
        }
    }
    for note in player.clear_all_notes() {
        route_note(&player_config, &mut port_id_to_conn, note, NOTE_OFF_MSG)
    }
    player_cleanup_finished.store(true);
    info!("Player Exiting.");

    Ok(())
}

fn route_note(
    player_config: &PlayerConfig,
    device_conn: &mut HashMap<usize, MidiOutputConnection>,
    playing: PlayingNote,
    midi_status: u8
) {
    match playing.note.u8_maybe() {
        None => { /* resting */ }
        Some(v) => {
            let note: [u8; 3] = [
                midi_status, v, playing.note.velocity
            ];

            match player_config.route(playing.channel_id) {
                None => {
                    error!("No port configured for channel! channel_id = {}", playing.channel_id);
                }
                Some(port_id) => {
                    device_conn.get_mut(port_id)
                        .unwrap() // TODO: nicer error handling
                        .send(&note)
                        .unwrap(); // TODO: nicer error handling
                }
            }
        }
    }
}
